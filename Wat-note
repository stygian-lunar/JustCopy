Note:

Perfect ðŸ‘ that makes things clearer.

So in your design:

* **Watcher service**

  * Runs every 1 min (cron/fixedRate).
  * Fetches expired rows with status = `ON_HOLD`.
  * Sends them to another service via Solace.
  * âŒ Does **not** update DB.

* **Another service**

  * Consumes messages from Solace.
  * Updates the row status â†’ `PROCESSED`.

---

## ðŸ”¹ Now what happens with `lockAtMostFor = 5m`

### Case 1: **Job finishes in 1 min**

* Watcher acquires lock at `T=0`.
* Sends records to Solace.
* Finishes at `T=1m`.
* **ShedLock releases the lock early** (doesnâ€™t hold it until 5m).
* At `T=2m`, the watcher can run again.
* âœ… No problem here.

---

### Case 2: **Job takes longer than lockAtMostFor** (e.g., 10 mins, lock = 5 mins)

* Lock expires before job completes.
* Another instance may acquire the lock and start scanning again.
* Since status is still `ON_HOLD` (watcher doesnâ€™t update), duplicates are sent to Solace.
* âš ï¸ Risk of duplicates, unless downstream service is idempotent.

---

## ðŸ”¹ Why you are safer in your case

* Because **the downstream service updates the status to PROCESSED**, duplicates are automatically avoided *after the status update*.
* But in the **window between Watcher sending â†’ Service processing â†’ Status updated**, the **same record may be sent again** if the watcher runs again and sees it still as `ON_HOLD`.

Example:

* At `T=0m`, watcher sends 100 records.
* At `T=1m`, watcher runs again â†’ DB still shows some as `ON_HOLD` (because other service hasnâ€™t updated yet).
* Those same records may be sent again.
* If Solace and the downstream service are **idempotent** (e.g., check `hold_trn_id` before marking processed), then **duplicates donâ€™t hurt**.

---

## ðŸ”¹ Options for You

1. **Keep as is, rely on downstream idempotency** âœ…

   * Make sure downstream ignores duplicates (based on unique `hold_trn_id`).
   * This is **already needed** since Solace guarantees *at-least-once delivery*.

2. **Introduce a temporary â€œIN\_PROGRESSâ€ marker**

   * Watcher marks rows as `IN_PROGRESS` before sending.
   * Prevents re-fetching the same row while Solace delivery is pending.
   * But this means watcher must perform an **UPDATE**, which you said you donâ€™t want.

3. **Increase lockAtMostFor**

   * If jobs are long (e.g., 10m), set lock to >10m.
   * Prevents mid-job overlap between instances.
   * Downside: recovery from crash is delayed until lock expiry.

4. **Switch to JobRunr**

   * Each record/batch becomes a persistent job.
   * If instance dies, another continues.
   * No time-based lock issues.

---

âœ… **Summary in your case:**

* If jobs finish within lockAtMostFor â†’ safe, no duplicates.
* If jobs run longer than lockAtMostFor â†’ duplicates may be sent, but downstream can safely ignore them (since it updates status).

---

ðŸ‘‰ Do you want me to show you how to **design the Solace consumer (downstream service) to be idempotent** so it safely handles duplicates from the watcher?
