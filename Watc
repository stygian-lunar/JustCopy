//base watchyer 

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.transaction.annotation.Transactional;
import net.javacrumbs.shedlock.core.LockProvider;
import net.javacrumbs.shedlock.core.SimpleLock;
import net.javacrumbs.shedlock.core.LockConfiguration;

import java.time.Instant;
import java.time.LocalDateTime;
import java.sql.Timestamp;
import java.time.Duration;
import java.util.List;
import java.util.Map;
import java.util.Optional;

public abstract class BaseWatcher {

    protected final Logger log = LoggerFactory.getLogger(this.getClass());

    protected final JdbcTemplate jdbcTemplate;
    protected final QueryLoader queryLoader;
    protected final LockProvider lockProvider;
    protected final ReleaseClient client;

    public BaseWatcher(JdbcTemplate jdbcTemplate,
                       QueryLoader queryLoader,
                       LockProvider lockProvider,
                       ReleaseClient client) {
        this.jdbcTemplate = jdbcTemplate;
        this.queryLoader = queryLoader;
        this.lockProvider = lockProvider;
        this.client = client;
    }

    /**
     * Executes a task with a ShedLock per table.
     */
    protected void executeWithTableLock(String tableName, Runnable task) {
        String lockName = "TABLE_LOCK_" + tableName;

        Optional<SimpleLock> lock = lockProvider.lock(
                new LockConfiguration(
                        lockName,
                        Instant.now(),
                        Duration.ofMinutes(5),  // lock duration
                        Duration.ofSeconds(10)  // lock acquisition timeout
                )
        );

        if (lock.isPresent()) {
            log.info("Acquired lock for table: {}", tableName);
            try {
                task.run();
            } finally {
                lock.get().unlock();
                log.info("Released lock for table: {}", tableName);
            }
        } else {
            log.warn("Another watcher is running for table {}; skipping execution.", tableName);
        }
    }

    /**
     * Executes a SELECT query with row-level locking (FOR UPDATE).
     */
    protected List<Map<String, Object>> selectRows(String tableName, String queryId, String status, LocalDateTime now) {
        String sql = queryLoader.getQuery(queryId).replace("${tableName}", tableName);

        Map<String, Object> params = Map.of(
                "status", status,
                "now", Timestamp.valueOf(now)
        );

        log.info("Executing SELECT on table {} for status={} and expiry_time <= {}", tableName, status, now);
        return jdbcTemplate.queryForList(sql, params);
    }

    /**
     * Processes rows by sending them to downstream client.
     */
    protected void processRows(List<Map<String, Object>> rows) {
        log.info("Processing {} rows for downstream service", rows.size());
        rows.forEach(row -> {
            log.debug("Sending row: {}", row);
            client.send(row);
        });
    }
}



// expiry watcher
import org.springframework.scheduling.concurrent.ConcurrentTaskScheduler;
import org.springframework.scheduling.TaskScheduler;
import org.springframework.scheduling.support.CronTrigger;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.List;
import java.util.Map;
import java.util.TimeZone;

@Service
public class ExpiryWatcher1 extends BaseWatcher {

    private final String tableName = "transactions";
    private final String queryId = "findExpired";
    private final ZoneId zone = ZoneId.of("Asia/Hong_Kong");
    private final TaskScheduler scheduler = new ConcurrentTaskScheduler();

    public ExpiryWatcher1(JdbcTemplate jdbcTemplate,
                          QueryLoader queryLoader,
                          LockProvider lockProvider,
                          ReleaseClient client) {
        super(jdbcTemplate, queryLoader, lockProvider, client);
        scheduleWatcher();
    }

    private void scheduleWatcher() {
        Runnable task = this::runWatcher;
        CronTrigger trigger = new CronTrigger("0 */1 * * * *", TimeZone.getTimeZone(zone));
        scheduler.schedule(task, trigger);
        log.info("Scheduled ExpiryWatcher1 for table {} with cron {}", tableName, "0 */1 * * * *");
    }

    @Transactional(readOnly = true)
    private void runWatcher() {
        LocalDateTime now = LocalDateTime.now(zone);
        log.info("ExpiryWatcher1 started at {}", now);

        executeWithTableLock(tableName, () -> {
            List<Map<String, Object>> rows = selectRows(tableName, queryId, StatusConstants.ON_HOLD, now);
            processRows(rows);
        });

        log.info("ExpiryWatcher1 finished at {}", LocalDateTime.now(zone));
    }
}
